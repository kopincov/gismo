/*
Random tests with:
- random hierarchical subdomain configuration (generated by randomized box insertions to the Quadtree)
- uniform knot vectors with different multiplicities- multiplicity added by random. max multiplicity is equal to degree

Parameter to change for different test cases:
    T_nlevels - the maximum numbre of levels
    test_num - number of tests (different box configurations)
    point_num - number of evaluation points
    max_deg_x - the maximum degree in x-direction
    max_deg_y - the maximum degree in y-direction
    num_knots_x - maximum number of inner knots in x direction- the real value i generated by random
    num_knots_x - maximum number of inner knots in y direction- the real value i generated by random
    rand_knot_num - maximum number of inserted knots- increase the multiplicity of the knots- does not add new knot values
    max_level - maximum number of hierarchical levels
    box_num - maximum number of boxes inserted into one level of hierarchy
*/

#include <iostream>
#include <set>
#include <map>
#include <ctime>

#include <gismo.h>

#include "common/random_refinement.h"


using namespace gismo;

int main(int argc, char *argv[])
{
  gsVector<index_t> iv1;
  gsVector<index_t> iv2;
  iv1.resize(2);
  iv2.resize(2);

  bool passed = true;

  ////////THB spline tests///////////////////////


    gsInfo << " ----- Test THBSplineBasis ----------  \n";
    gsInfo << " Uniform knots with different multiplicities and d+1 multiplicity at the boundary."<<"\n";
    srand((unsigned)time(NULL));//seed the random alg.


    index_t test_num = 3;
    index_t point_num = 50;
    index_t max_deg_x = 3;
    index_t max_deg_y = 3;
    index_t num_knots_x = 10;
    index_t num_knots_y = 10;
    index_t rand_knot_num = 10;
    index_t max_level = 3;
    index_t box_num = 5;
    
    gsCmdLine cmd("Generates random hierarchy configuration and test the partition of unity");
    cmd.addInt("t", "test_num", "Number of tests", test_num);
    cmd.addInt("p", "points", "Number of evaluated points", point_num);
    cmd.addInt("x", "max_deg_x", "Maximum degree in x direction", max_deg_x);
    cmd.addInt("y", "max_deg_y", "Maximum degree in y direction", max_deg_y);
    cmd.addInt("j", "max_knots_x", "Maximum number of knots in x direction", num_knots_x);
    cmd.addInt("k", "max_knots_y", "Maximum number of knots in y direction", num_knots_y);
    cmd.addInt("r", "random_knots", "maximum randomly inserted knots", rand_knot_num);
    cmd.addInt("l", "maximum_level", "maximum posible level", max_level);
    cmd.addInt("b", "boxes", "maximum number of boxes inserted in one level", box_num);
    
    try { cmd.getValues(argc,argv); } catch (int rv) { return rv; }

    if (test_num < 1)
    {
        std::cerr << "Number of tests must be positive.\n"; return -1;
    }
    if (point_num < 1)
    {
        std::cerr << "Number of points must be positive.\n"; return -1;
    }
    if (max_deg_x < 1)
    {
        std::cerr << "Degree x must be positive.\n"; return -1;
    }
    if (max_deg_y < 1)
    {
        std::cerr << "Degree y must be positive.\n"; return -1;
    }



     gsInfo << " Number of tests: "<< test_num <<"\n";
     gsInfo << " Number of points: "<< point_num <<"\n";
    for(int i =0; i < test_num;i++){
        gsInfo << " ------------------------------------------------------------------------------ test number "<<i<<" \n";
        int deg_x = (rand()%max_deg_x)+1;
        int deg_y = (rand()%max_deg_y)+1;
        int kn = (rand()%num_knots_x)+1;
        gsKnotVector<> T_KV (0, 1, kn , deg_x+1, 1 ) ;
        kn = (rand()%num_knots_y)+1;
        gsKnotVector<> T_KV1 (0, 1,kn,deg_y+1,1) ;
        gsInfo<<"Knot Vector"<<T_KV<<"\n";
        gsInfo<<"Knot Vector"<<T_KV1<<"\n";
        for (int i2 = 0; i2 < rand_knot_num; i2 ++){
            int kn2 = rand()%T_KV.size();
            if(T_KV.multiplicity(T_KV[kn2]) < deg_x) {
                T_KV.insert(T_KV[kn2]);
            }
        }
        for (int i3 = 0; i3 < rand_knot_num; i3 ++){
            int kn3 = rand()%T_KV1.size();
            if(T_KV1.multiplicity(T_KV1[kn3]) < deg_y){
                T_KV1.insert(T_KV1[kn3]);
            }
        }
        gsInfo<<"Knot Vector"<<T_KV<<"\n";
        gsInfo<<"Knot Vector"<<T_KV1<<"\n";
        gsTensorBSplineBasis<2,real_t> T_tbasis( T_KV, T_KV1 );

        int T_nlevels =(rand()%max_level)+2;
        //helps to create the refinement
        gsTHBSplineBasis<2>  TT ( T_tbasis ) ;
        gsTHBSplineBasis<2>  THB ( T_tbasis ,random_refinement(T_nlevels-1, box_num, &TT)) ;
        //gsInfo<<"knot vector"<< THB.m_cvs[0][0]<<"\n";
        //gsInfo<<"knot vector"<< THB.m_cvs[1][0]<<"\n";

        gsInfo<<"Basis has degree "<< deg_x <<" and "<< deg_y <<". The number of levels is "<< T_nlevels<<"\n";


        gsInfo<<"The tree has "<< THB.tree().size() << " nodes.\n" << "\n";
        //set the matrices
        //THB.initialize();
        gsMatrix<> T_para  = THB.support();
        gsInfo<<"\n"<< "The parameter range is: "<< "\n" << T_para <<"\n";

        gsVector<> T_c0 = T_para.col(0);
        gsVector<> T_c1 = T_para.col(1);

        gsMatrix<> T_pts = uniformPointGrid(T_c0,T_c1, point_num) ;

        gsMatrix<>   T_ev  = THB.eval( T_pts) ;

       //gsMatrix<index_t> * act = THB.active( *T_pts ) ;
        //gsMatrix<index_t> act;
        //THB.hier_active_into(*T_pts,act);
        //gsInfo<<"points\n"<< *T_pts   <<"\n";
        //gsInfo<<"eval  \n"<<  T_ev    <<"\n";
        //gsInfo<<"act   \n"<< act   <<"\n";

        real_t sum=0;
        bool k = true;

        gsMatrix<> sum2=T_ev.colwise().sum();

        std::cout<<sum2<<std::endl;

        for(int i4 = 0; i4 < T_ev.cols();i4++)
        {
            for(int j = 0; j < T_ev.rows();j++)
            {
                sum += T_ev(j,i4);
            }
            if ( ! math::almostEqual<real_t>(1.0, sum) )
            {
                gsInfo<<"something wrong at column "<<i4<<"\n";
                k = false;
                passed = false;
                gsInfo<<"sum"<<sum<<"\n";
                gsInfo<< T_pts(0,i4)<<"  "<< T_pts(1,i4)<<"\n";
                //break;
                sum =0;
            }else
            {
                sum =0;
            }

        }
        if(k){
            gsInfo<<"everything went as expected"<<"\n";

        }else{
            break;
        }
       //delete THB;
    }

    return passed ? 0 : 1;
}

