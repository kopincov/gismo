

/*
  Random tests with:
  - one hierarchical level over half of the domain
  - tests for the not truncated basis functions of level 0- comparison with standars tensor basis functions for eval, deriv, deriv2

  Parameter to change for different test cases:
  T_nlevels - the maximum numbre of levels
  test_num - number of tests (different box configurations)
  point_num - number of evaluation points
  max_deg_x - the maximum degree in x-direction
  max_deg_y - the maximum degree in y-direction
  num_knots_x - maximum number of inner knots in x direction- the real value i generated by random
  num_knots_x - maximum number of inner knots in y direction- the real value i generated by random
  rand_knot_num - maximum number of inserted knots- increase the multiplicity of the knots- does not add new knot values
*/


#include <iostream>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */

#include <gismo.h>

using namespace gismo;

int main()
{
    gsVector<index_t,2> iv1;
    gsVector<index_t,2> iv2;

    bool passed = true;

    const real_t tol = std::pow(10.0, - REAL_DIG*0.75 );
    gsInfo <<"Using tolerance: " << tol <<"\n"; 
    ////////THB spline tests///////////////////////


    gsInfo << " ----- Test THBSplineBasis ----------  \n";
    gsInfo << " Uniform knots with different multiplicities and d+1 multiplicity at the boundary."<<"\n";
    srand((unsigned)time(NULL));//seed the random alg.

    int test_num = 3;
    int point_num = 10;
    int max_deg_x = 3;
    int max_deg_y = 4;
    int num_knots_x = 5;
    int num_knots_y = 5;
    int rand_knot_num = 3;
    //int max_level = 2;
    //int box_num = 5;
    gsInfo << " Number of tests: "<< test_num <<"\n";
    gsInfo << " Number of points: "<< point_num <<"\n";
    for(int i =0; i < test_num;i++){
        gsInfo << " ------------------------------------------------------------------------------ test number "<<i<<" \n";
        int deg_x = (rand()%max_deg_x)+1;
        int deg_y = (rand()%max_deg_y)+1;
        int kn = (rand()%num_knots_x)+1;
        gsKnotVector<> T_KV (0, 1, kn , deg_x+1, 1 ) ;
        // for degree 4 we must have at least 19 internal knots
        // that all active basis function on [0, 0.3] time [0, 0.3] are
        // not truncated
        kn = 18 + (rand() % num_knots_y) + 1;
        gsKnotVector<> T_KV1 (0, 1,kn,deg_y+1,1) ;
        gsInfo<<"Knot Vector"<<T_KV<<"\n";
        gsInfo<<"Knot Vector"<<T_KV1<<"\n";
        for (int i2 = 0; i2 < rand_knot_num; i2 ++){
            int kn2 = rand()%T_KV.size();
            if(T_KV.multiplicity(T_KV[kn2]) < deg_x ){
                T_KV.insert(T_KV[kn2]);
            }
        }
        for (int i3 = 0; i3 < rand_knot_num; i3 ++){
            int kn2 = rand()%T_KV1.size();
            if(T_KV1.multiplicity(T_KV1[kn2]) < deg_y ){
                T_KV1.insert(T_KV1[kn2]);
            }
        }

        //some random knots
        //T_KV1.insert(0.11);
        //T_KV1.insert(0.911);
        //T_KV1.insert(0.812);
        //T_KV1.insert(0.758);


        gsInfo<<"Knot Vector after increasing multiplicity"<<T_KV<<"\n";
        gsInfo<<"Knot Vector after increasing multiplicit"<<T_KV1<<"\n";

        gsTensorBSplineBasis<2,real_t> T_tbasis( T_KV, T_KV1 );

        int T_nlevels =2;

        iv1[0] = 0;
        iv1[1] = (T_KV1.uSize()/2) << (10 - 1);
        iv2[0] = (T_KV.uSize()-1) << (10 - 1);
        iv2[1] = (T_KV1.uSize()-1) << (10 - 1);

        std::vector<index_t> q;
        q.push_back(T_nlevels-1);
        q.push_back(iv1[0]);
        q.push_back(iv1[1]);
        q.push_back(iv2[0]);
        q.push_back(iv2[1]);
        gsTHBSplineBasis<2>  THB ( T_tbasis , q) ;

        gsInfo<<"knot vector in tHB"<< THB.getBases()[0]->component(0).knots()<<"\n"; //THB.m_cvs[0][0]<<"\n";
        gsInfo<<"knot vector in tHB"<< THB.getBases()[0]->component(1).knots()<<"\n"; //THB.m_cvs[1][0]<<"\n";
        gsInfo<<"Basis has degree "<< deg_x <<" and "<< deg_y <<". The number of levels is "<< T_nlevels<<"\n";

        gsInfo<<"The tree has "<< THB.tree().size() << " nodes.\n" << "\n";

        THB.printCharMatrix();

        gsMatrix<> T_para  = THB.support();
        //gsInfo<<"\n"<< "The parameter range is: "<< "\n" << T_para <<"\n";
        T_para(0,0)= 0;
        T_para(1,0)= 0.0;
        T_para(0,1)= 0.3;
        T_para(1,1)= 0.3;
        gsInfo<<"\n"<< "The parameter range is: "<< "\n" << T_para <<"\n";
        gsVector<> T_c0 = T_para.col(0);
        gsVector<> T_c1 = T_para.col(1);
        gsMatrix<> T_pts = uniformPointGrid(T_c0,T_c1, point_num) ;
        gsMatrix<real_t, 2> u(2,1) ;
        u(0,0) =0.2;  u(1,0) =0.1;
        gsMatrix<>   T_ev  = THB.eval( T_pts) ;
        gsMatrix<>   T_deriv  = THB.deriv( T_pts) ;
        gsMatrix<>   T_deriv2  = THB.deriv2( T_pts) ; // path of computation ??

        //create tensor baiss

        //evaluate at the same points
        //compare the coresponding values

        gsTensorBSplineBasis<2,real_t> test_tbasis( T_KV, T_KV1 );
        gsMatrix<>   B_ev  = test_tbasis.eval( T_pts) ;
        gsMatrix<>   B_deriv  = test_tbasis.deriv( T_pts) ;
        gsMatrix<>   B_deriv2  = test_tbasis.deriv2( T_pts); // same as evalAllDers




/// the following test works only if they are used on the non truncated part of the domain-otherwise it  has errors-
/// they test if the standard tenor basis functions evaluate to the same value as the not truncated basis functions of lvl 0 of the THB basis
///////////////////////////////// eval comparison/////////////////////////////
///
///
///
        bool compare_eval= true;
        for(int i3 = 0; i3 < T_ev.cols();i3++){
            for(int j = 0; j < T_ev.rows();j++){
                if ( ! math::almostEqual<real_t>(T_ev(j,i3), B_ev(j,i3)) )
                {
                    gsInfo<<"Values of TB and THB are different : "
                          << B_ev(j,i3)  <<" ~ "<< T_ev(j,i3) <<"\n";
                    compare_eval = false;
                    passed = false;
                }
            }
        }
        if(compare_eval)
            gsInfo<<"the values ot THB and tensor basis are the same :)"<<"\n";

        compare_eval = true;
        for(int i4 = 0; i4 < T_deriv.cols();i4++)
        {
            for(int j = 0; j < T_deriv.rows();j++)
            {
                // Note: increasing ULPs due to 
                // gsBSplineBasis::deriv_into vs gsBSplineBasis::derivSingle_into
                //if ( ! math::almostEqualUlp<real_t>(T_deriv(j,i), B_deriv(j,i), 10) )
                if ( math::abs(T_deriv(j,i4)-B_deriv(j,i4)) >  tol )
                {
                    gsInfo<<"Derivatines of TB and THB are different : "
                          << B_deriv(j,i4)  <<" ~ "<< T_deriv(j,i4) <<" diff: "<<T_deriv(j,i4)-B_deriv(j,i4)<<"\n";
                    compare_eval = false;
                    passed = false;
                }
            }
        }
        if(compare_eval)
            gsInfo<<"the derivatives of THB and tensor basis are the same :)"<<"\n";

        compare_eval = true;
        for(int i5 = 0; i5 < T_deriv2.cols();i5++)
        {
            for(int j = 0; j < T_deriv2.rows();j++)
            {
                //if ( ! math::almostEqual<real_t>(T_deriv2(j,i), B_deriv2(j,i)) )
                if ( math::abs(T_deriv2(j,i5)-B_deriv2(j,i5)) > tol * 10 )
                {
                    gsInfo<<"2nd derivatives of TB and THB are different : "
                          << B_deriv2(j,i5)  <<" ~ "<< T_deriv2(j,i5) << "\n";
                    compare_eval = false;
                    passed = false;
                }
            }
        }
        if(compare_eval)
            gsInfo<<"the second derivatives of THB and tensor basis are the same :)"<<"\n";

//////////////////////////////////////////////////////////////////////////////////////
        real_t sum=0;
        bool k = true;
        for(int i6 = 0; i6 < T_ev.cols();i6++)
        {
            for(int j = 0; j < T_ev.rows();j++)
                sum += T_ev(j,i6);

            if ( ! math::almostEqual<real_t>(1.0, sum) )
            {
                gsInfo<<"something wrong at column "<<i6<<"\n";
                k = false;
                passed = false;
                gsInfo<<"sum"<<sum<<"\n";
                gsInfo<< T_pts(0,i6)<<"  "<< T_pts(1,i6)<<"\n";
                //break;
                sum =0;
            }else{
                sum =0;
            }

        }
        if(k){
            gsInfo<<"everything went as expected- the sum is 1 everywhere"<<"\n";

        }else{
            break;
        }       

        //delete THB;
    }

    return passed ? 0 : 1;
}

