/** @file gsFittingIdConstr.h

    @brief Contains the class permitting the construction of some
    "Identity map" used for example for the initialisation of iterative
    algorithms.

    This file is part of the G+Smo library.

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.

    Author(s): Y. Masson
*/

#pragma once

#include <gsCore/gsForwardDeclarations.h>
#include <gsCore/gsMultiBasis.h>

#include <gsNurbs/gsTensorBSplineBasis.h>


#include <gsFitting/gsFittingIterator.h>
#include <gsFitting/gsFittingIntegrand.h>
#include <gsFitting/gsFittingEnergy.h>
#include <gsFitting/gsFittingQuadrature.h>
#include <gsFitting/gsLeastSquares.h>
#include <gsFitting/gsFittingUtilsCheck.h>

namespace gismo
{

template<short_t d, class GenBasis, class T>
class gsFittingBase;

/**
   @brief Class that permits to construct the identity used for the fitting. This computation is obtained by minimizing some energy on a space generated by very simple spline basis functions. Generally the basis functions used are d-linear (degree 1 with 0 interior nodes)
**/
template<short_t d, class GenBasis, class T=real_t>
class _gsFittingIdConstr
{

public:
    typedef typename std::vector<gsMatrix<T> > Container;
    /// Constructor: set the degree
    _gsFittingIdConstr(bool export_iter, std::string& output,
                              int degree = 1);

    /// destructor: delete the template
    ~_gsFittingIdConstr()
    {
        if(m_template != NULL)
            delete m_template;
    }

    /// Compute the template. The result is set in m_template
    void init_identity_mapping(unsigned dim_im,
                               gsFittingEnergy<GenBasis, T>& ener);

    /// Compute the expected mapping
    gsFunctionSet<T>* compute(gsFittingBase<d, GenBasis, T>& fitt);

    /// Return the result of the computation
    gsFunctionSet<T>* get_template(){ return m_template; }

protected:

    /// The degree of the basis (generally 1)
    int m_degree;

    /// The path used for the exportation
    std::string m_output;

    /// If true, we export each template constructed
    bool m_export;

    /// the result of the computation
    gsFunctionSet<T>* m_template;
};


template<short_t d, class GenBasis, class T = real_t>
class gsFittingIdConstr
    : public _gsFittingIdConstr<d, GenBasis, T>
{

public:
    typedef _gsFittingIdConstr<d, GenBasis, T> Base;

    /// constructor
    gsFittingIdConstr(GenBasis &model, bool export_iter,
                             std::string& output,
                      int degree = 1);

    /// Initialize the basis used for the computation
    void init_basis(GenBasis &model);

    /// Return the basis used for the computation
    GenBasis& basis();

private:
    using Base::m_degree;
};


template<short_t d, class T>
class gsFittingIdConstr<d, gsBasis<T>, T>
    : public _gsFittingIdConstr<d, gsBasis<T>, T>
{

public:
    typedef _gsFittingIdConstr<d, gsBasis<T>, T> Base;
    /// constructor: initialize the basis used for the construction
    ///              of the template
    gsFittingIdConstr(gsBasis<T> &model, bool export_iter,
                      std::string& output,
                      int degree = 1);

    /// Initialize the basis used for the computation
    void init_basis(gsBasis<T> &model);

    /// Return the basis used for the computation
    gsBasis<T>& basis(){ return m_basis; }


private:
    /// the (most probably linear) basis on which is defined
    /// the template
    gsTensorBSplineBasis<d,T> m_basis; // = gsTensorBSplineBasis for d>1, gsBSplineBasis for d=1

    using Base::m_degree;
};



template<short_t d, class T>
class gsFittingIdConstr<d, gsMultiBasis<T>, T>
    : public _gsFittingIdConstr<d, gsMultiBasis<T>, T>
{

public:
    typedef _gsFittingIdConstr<d, gsMultiBasis<T>, T> Base;

    /// constructor: initialize the basis used for the construction
    ///              of the template
    gsFittingIdConstr(gsMultiBasis<T> &model, bool export_iter,
                      std::string& output,
                      int degree = 1);

    /// Initialize the basis used for the computation
    void init_basis(gsMultiBasis<T> &model);


    /// Return the basis used for the computation
    gsMultiBasis<T>& basis(){ return m_basis; }

private:
    /// the (most probably linear) basis on which is defined
    /// the template
    gsMultiBasis<T> m_basis;

    using Base::m_degree;
}; /// class gsFittingIdConstr


} /// namespace gismo


#ifndef GISMO_BUILD_LIB
#include GISMO_HPP_HEADER(gsFittingIdConstr.hpp)
#endif

//////////////////////////////////////////////////
//////////////////////////////////////////////////
