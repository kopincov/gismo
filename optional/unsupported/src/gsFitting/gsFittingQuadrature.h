/** @file gsFittingQuadrature.h

    @brief Contains gsFittingQuadrature that permits to travel
    along a domain to perform the quadrature of some energies used
    for fitting.
    This file is part of the G+Smo library.

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.

    Author(s): Y. Masson
*/

#pragma once

#include <gsCore/gsForwardDeclarations.h>
#include <gsFitting/gsFittingIterator.h>
#include <gsFitting/gsFittingIntegrand.h>
#include <gsFitting/gsLocalGlobal.h>
#include <gsFitting/gsFittingSystem.h>

namespace gismo
{

template<class GenBasis, unsigned o, class T>
class gsFittingQuadratureGen
{
public:
    virtual void decrease_coeff_smoothing(T ratio) = 0;
    virtual void decrease_linear_coeff_smoothing(T ratio) = 0;
    virtual bool has_smoothing() = 0;
    virtual bool has_fitting() = 0;
    virtual bool canSplitDimension() = 0;
    virtual bool isLinear() = 0;

    virtual void set_identity_mapping(gsFunctionSet<T>* identity_map) = 0;
    virtual void assembleSystem(gsFittingSystem<GenBasis, T>& system,
                        bool isLinear) = 0;
    virtual void set_current_map(gsFunctionSet<T>* current_map) = 0;

    virtual T minError() = 0;
    virtual T maxError() = 0;
    virtual T totalError() = 0;

    virtual T minEnergySmoothing() = 0;
    virtual T maxEnergySmoothing() = 0;
    virtual T totalEnergySmoothing() = 0;

    virtual void computeEnergies(int type = 1) = 0;
};

/**
   @brief Compute the quadrature over a parameter domain of certain
   energies contained in a vector of gsFittingIntegrand objects.
   A mapping from the parameter domain to the domain of a basis
   is given.
   The function assembleSystem performs a quadrature on the parameter
   domain to construct the matrix and the RHS associated with the
   minimization of the sum of these energies on the function space
   generated by this basis.

   d : the dimension of the parameter space
   GenBasis : the type of the basis defined on the domain (simple or multipatch)
   o : the maximal order needed (o between 0 and 2)

   Remark: if the parameter space is different from the identity,
   then the basis must be a gsBasis (single patch)
   the integrands are deleted whenever the destructor is called
**/
template<short_t d, class GenBasis, unsigned o, class T>
class gsFittingQuadrature
    : public gsFittingQuadratureGen<GenBasis, o, T>
{

public:

    /// Constructor: create a gsFittingQuadrature with no integrand
    gsFittingQuadrature(GenBasis& basis, unsigned dim_im,
                        gsFunctionSet<T>* domain = NULL,
                        int *size_quadr = NULL) :
    m_basis(basis),
    m_actives(), m_image(), m_der1(), m_der2()
    {
        m_domain = domain;
        init_size_quadr(size_quadr);
        m_split_dim = true;
        m_isLinear = true;
        m_current = NULL;
        m_dim = dim_im;
    }

    /// Copy
    gsFittingQuadrature(const gsFittingQuadrature
                        <d, GenBasis, o, T>& quadr)
    : m_basis(quadr.m_basis), m_actives(), m_image(),
      m_der1(), m_der2()
    {
        m_domain = quadr.m_domain;
        init_size_quadr(quadr.m_size_quadr);
        m_integrand = quadr.m_integrand;
        m_split_dim = quadr.m_split_dim;
        m_isLinear = quadr.m_isLinear;
        m_current = quadr.m_current;
        m_dim = quadr.m_dim;
    }

    gsFittingQuadrature<d, GenBasis, o, T>&
    operator= ( const gsFittingQuadrature<d, GenBasis, o, T>
                                     & other );

    /// Destructor
    virtual ~gsFittingQuadrature(){ removeAll(); }

    /// Copy a gsFittingQuadrature, with possibly a new basis
    gsFittingQuadrature<d, GenBasis, o, T>* copy
    (GenBasis* new_basis = NULL)
    {
        GenBasis* _new_basis = new_basis;
        if(new_basis == NULL)
            _new_basis = &m_basis;
        return new gsFittingQuadrature
            <d, GenBasis, o, T>(*_new_basis, m_dim, m_domain,
                                m_size_quadr);
    }

    /// Multiply the coefficient of all the smoothing energies by ratio
    void decrease_coeff_smoothing(T ratio)
    {
        unsigned s = m_integrand.size();
        for(unsigned i = 0;i < s;i++)
        {
            if(m_integrand[i]->is_smoothing())
                m_integrand[i]->decrease_coeff_smoothing(ratio);
        }
    }


    void decrease_linear_coeff_smoothing(T ratio)
    {
        unsigned s = m_integrand.size();
        for(unsigned i = 0;i < s;i++)
        {
            if(m_integrand[i]->is_smoothing())
                m_integrand[i]->
                    decrease_linear_coeff_smoothing(ratio);
        }
    }


    /// Add an integrand to the quadrature
    void addIntegrand(gsFittingIntegrand<d, T>* new_integrand)
    {
        m_integrand.push_back(new_integrand);
        set_properties_integrand();
    }

    /// Returns true if one of the integrands is of smoothing type
    bool has_smoothing()
    {
        unsigned s = m_integrand.size();
        for(unsigned i = 0;i<s;i++)
        {
            if(m_integrand[i]->is_smoothing())
                return true;
        }
        return false;
    }

    /// Returns true if one of the integrands is of fitting type
    bool has_fitting()
    {
        unsigned s = m_integrand.size();
        for(unsigned i = 0;i<s;i++)
        {
            if(! m_integrand[i]->is_smoothing())
                return true;
        }
        return false;
    }

    /// Set the identity mapping to the integrands that depend
    /// on the deformation
    void set_identity_mapping(gsFunctionSet<T>* identity_map)
    {
        unsigned s = m_integrand.size();
        for(unsigned i = 0;i<s;i++)
        {
            m_integrand[i]->set_identity_mapping(identity_map);
        }
    }

    /// Called to reset the vector of integrands
    void init_quadrature(std::vector<gsFittingIntegrand<d, T>*>
                         & integrand)
    {
        unsigned s = m_integrand.size();
        for(unsigned i = 0;i<s;i++)
            delete m_integrand[i];

        m_integrand = integrand;
        set_properties_integrand();
    }

    /// Add the components associated with this quadrature
    /// (i.e. with the list of integrands contained in
    ///  this quadrature) to the matrix and to the RHS.
    /// Note that the matrix is represented here by a
    /// gsSparseEntries to speed up the construction.
    /// Also, some nonlinear energies can be contained in other
    /// quadrature elements.
    /// split_dim: can we split the dimensions in the global system
    /// isLinear: is the global energy linear
    void assembleSystem(gsFittingSystem<GenBasis, T>& system,
                        bool isLinear);

    /// Sets the current map (used for nonlinear systems)
    void set_current_map(gsFunctionSet<T>* current_map)
    {  m_current = current_map;   }

    /// Copies all the fitting type elements from origin to dest.
    static bool copy_non_smoothing_integrand
    (gsFittingQuadrature<d, GenBasis, o, T>& origin,
     gsFittingQuadrature<d, GenBasis, o, T>& dest);

    /// Return true if all the integrands of this quadrature
    /// can consider the dimensions separatly
    bool canSplitDimension() { return m_split_dim;  }

    /// Return true if the system is linear.
    bool isLinear() { return m_isLinear;  }

    void removeAll()
    {
        unsigned s = m_integrand.size();
        for(unsigned i = 0;i < s;i++)
            delete m_integrand[i];
        m_integrand.clear();
    }

    gsFittingIntegrand<d, T>* integrand(int ind)
    {
        GISMO_ASSERT(ind < m_integrand.size(),
                     "ERROR: index invalid");
        return m_integrand[ind];
    }

private:
    /// Compute the values and derivatives of the active basis functions
    /// at each points. The center point is used to find
    /// all the active basis functions
    void compute_basis(gsMatrix<T>& pts,
                       gsBasis<T>& basis,
                       gsMatrix<T>& centerPoint);

    /// Compute the values and derivatives of the
    /// current position (solution)
    void compute_current(gsMatrix<T>& pts,
                         gsGeometry<T>& geom);

    /// Compute the positions of the quadrature points both
    /// on the parameter domain and on the domain of the
    /// basis functions. Recall that these are the image of
    /// the points of the parameter points by the mapping m_domain.
    void compute_quadrature_points(gsGenGeomIterator<T>& domIt,
                                   gsGaussRule<T>& QuRule,
                                   gsMatrix<T>& quNodes_param,
                                   gsMatrix<T>& quNodes,
                                   gsVector<T>& quWeights);

    /// Construct a domain iterator in the two following possible cases:
    /// - m_domain is NULL: the domain iterator is an iterator
    /// on the domain of the basis functions
    /// - otherwise: the domain iterator is an iterator on m_domain
    gsGenGeomIterator<T>* generic_template_iterator();

    /// Set the size of the quadrature, i.e., the number of points used.
    void init_size_quadr(const int *size_quadr = NULL)
    {
        for(unsigned i = 0;i < d;i++)
        {
            if(size_quadr != NULL)
                m_size_quadr[i] = size_quadr[i];
            else
                m_size_quadr[i] = std::max(m_basis.degree(i), (short_t)2);
        }
    }

public:
    /// These functions return the minimal, the maximal and the sum
    /// of the errors of the energy of type fitting associated
    /// with this quadrature
    /// !!! computeEnergies must be called before these functions
    /// are called
    T minError(){  return m_minError;  }
    T maxError(){  return m_maxError;  }
    T totalError(){  return m_totalError;  }

    /// These functions return the minimal, the maximal and the sum
    /// of the energies of type smoothing associated
    /// with this quadrature
    /// !!! computeEnergies must be called before these functions
    /// are called
    T minEnergySmoothing(){  return m_minEnergySmoothing;  }
    T maxEnergySmoothing(){  return m_maxEnergySmoothing;  }
    T totalEnergySmoothing(){  return m_totalEnergySmoothing;  }

    /// Perform the quadrature to compute the energies associated
    /// with this quadrature for the current position (solution).
    void computeEnergies(int type = 1);

private:
    /// Sets a given error (or energy) at a given position
    T set_local_value(int type, T _err, bool is_error);

    /// Resets the error data to zero
    void reset_error();

    /// Actualizes the properties of the integrands (linear,...).
    /// Must be called after each modification of the vector
    /// of integrands
    void set_properties_integrand();

private:
    inline void add_matrix(gsFittingSystem<GenBasis, T>& system,
                           int i, int j,
                           int ind_i, int ind_j, int patch,
                           std::vector<gsMatrix<T> >& localA)
    {
        int s = localA.size();
        std::vector<T> _localA(s);
        for(int ind = 0;ind < s;ind++)
            _localA[ind] = localA[ind](i, j);
        system.add_matrix(ind_i, ind_j, patch, _localA);
    }


protected:
    /// the domain on which is performed the quadrature
    /// if NULL, we consider this mapping as the identity.
    /// The domain is in that case the domain of the basis functions.
    gsFunctionSet<T>* m_domain;

    /// The basis defined on the image of m_domain.
    /// Note that if m_domain if NULL, then m_basis is
    /// necessarily a gsBasis (single patch case)
    /// in the current implementation.
    GenBasis& m_basis;

    /// The errors given by the integrands of type fitting
    std::vector< gsMatrix<T> > m_errors;

    /// Maximal, minimal and total error
    T m_maxError;
    T m_minError;
    T m_totalError;

    /// The energy given by the integrands of type smoothing
    std::vector< gsMatrix<T> > m_energySmoothing;

    /// Maximal, minimal and total energy
    T m_maxEnergySmoothing;
    T m_minEnergySmoothing;
    T m_totalEnergySmoothing;

    /// The integrands that will be considered in this quadrature
    std::vector< gsFittingIntegrand<d, T>* > m_integrand;

    /// ******* Elements computed at each elementary cell ********

    /// The index of the basis functions that are actives
    /// (at the current elementary cell)
    gsMatrix<index_t> m_actives;

    /// The images and derivatives of the active basis functions
    /// at the current quadrature points
    gsMatrix<T> m_image;
    gsMatrix<T> m_der1;
    gsMatrix<T> m_der2;

    /// The images and derivatives of the current solution
    /// at the current quadrature points
    gsMatrix<T> m_image_curr;
    gsMatrix<T> m_der1_curr;
    gsMatrix<T> m_der2_curr;

    /// The current solution (see gsFittingIntegrand for some more
    /// details on the linearization of nonlinear energies)
    gsFunctionSet<T>* m_current;

    /// True if we can compute independently the dimensions
    /// for this quadrature
    bool m_split_dim;

    /// True if the energy associated with this quadrature does not
    /// prevent a splitting of the dimensions
    bool m_isLinear;

    /// The number of points used for Gaussian quadrature
    int m_size_quadr[d];

    /// The dimension of the domain in which is embedded the
    /// mapping that is being computed
    unsigned m_dim;

}; /// gsFittingQuadrature

}// namespace gismo

#ifndef GISMO_BUILD_LIB
#include GISMO_HPP_HEADER(gsFittingQuadrature.hpp)
#endif

//////////////////////////////////////////////////
//////////////////////////////////////////////////
