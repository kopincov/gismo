/** @file gsFittingUtilsProjection.h

    @brief Contains routines permitting to compute the (L2)
    projection of mappings onto the linear functional
    space generated by some basis. Two methods are implemented:
   - basisProjectionSampling: we sample some points from
     the geometry and we then use least squares method to
     compute the new geometry defined on the given basis.
   - basisProjectionContinuous: we compute directly
     the L2 minimization.

    This file is part of the G+Smo library.

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.

    Author(s): Y. Masson
*/

#pragma once

namespace gismo
{

/// Samples points from mapping and then applies the least squares method
template<short_t d, class GenBasis, class T> gsFunctionSet<T>*
basisProjectionSampling(GenBasis& basis, int dim,
                        gsFunctionSet<T>& mapping,
                        bool exp_sampling = false);

/// Minimizes the L2 distance with mapping.
template<short_t d, class GenBasis, class T>
gsFunctionSet<T>* basisProjectionContinuous(GenBasis& basis, int dim,
                                            gsFunctionSet<T>& mapping);

/// Project a gsGeometry restricted using (start, end)
/// on a new basis using interpolation
/// start = 0. means that we start at the beginning
/// of the domain of geom
/// end = 1 means that we stop at the end
/// of the domain of geom
template<class T> gsGeometry<T>*
basisProjectionInterpolation(boxSide border, gsBasis<T>& basis,
                             gsGeometry<T>& geom,
                             gsGeometry<T>& temp,
                             const std::vector<T>& start
                             = std::vector<T>(),
                             const std::vector<T>& end
                             = std::vector<T>());

template<class T> gsGeometry<T>*
basisProjectionInterpolation(boxSide border, gsBasis<T> basis,
                             std::vector<gsMatrix<T> >& pts,
                             std::vector<gsMatrix<T> >& param,
                             const std::vector<T>& start = std::vector<T>(),
                             const std::vector<T>& end = std::vector<T>());


template<short_t d, class GenBasis, class T> gsFunctionSet<T>*
basisProjectionSampling(GenBasis& basis, int dim,
                        gsFunctionSet<T>& mapping,
                        bool exp_sampling)
{
    std::vector< gsMatrix<T> > vect_param;
    std::vector< gsMatrix<T> > vect_geom;
    gsPointsSampling<GenBasis, T> points_sampler(basis);
    std::vector<index_t> sizes = points_sampler.sizes();
    unsigned s = sizes.size();
    bool remove_result = false;

    for(unsigned i =0;i < s;i++)
    {
       vect_param.push_back(gsMatrix<T>(d, sizes[i]));
       vect_geom.push_back(gsMatrix<T>(d, sizes[i]));
    }

    points_sampler.points_sampling(vect_param);
    generic_eval_into(basis, mapping,
                      vect_param, vect_geom);

    if(exp_sampling)
    {
        std::string _path = "pts_sampling";
        std::string _path2 = "image_sampling";
        for(unsigned i = 0;i < s;i++)
        {
            std::string path = _path + util::to_string(i);
            std::string path2 = _path2 + util::to_string(i);
            gsWriteParaviewPoints(vect_param[i], path);
            gsWriteParaviewPoints(vect_geom[i], path2);
        }
    }
    std::string output = "";
    gsFittingParam<T> param;

    index_t nBases = nBasesGen<T>(basis);
    gsFittingBase<d, GenBasis, T>
        fitt_id(dim, basis, remove_result,
                param, gsPointContainer<T>(nBases));

    fitt_id.resetPointsLS(vect_geom, vect_param);
    fitt_id.compute();
    return fitt_id.result();
}


template<short_t d, class GenBasis, class T> gsFunctionSet<T>*
basisProjectionContinuous(GenBasis& basis, int dim,
                          gsFunctionSet<T>& mapping)
{
    gsFittingParam<T> param;
    param.deform_min = false;

    bool remove_result = false;
    gsFittingBase<d, GenBasis, T>
        fitt_id(dim, basis, remove_result, param);

    gsFittingQuadrEnergy<GenBasis, T>& quadrEner
        = fitt_id.quadrEner();
    std::vector< gsFittingQuadrature<d, GenBasis, 2, T> >&
        _quadr( quadrEner.template
               getQuadratures<d>() );
    gsFunctionSet<T>* tmp = NULL;
    _quadr.push_back(
        gsFittingQuadrature<d, GenBasis, 2, T>
        (basis, dim, tmp));

    add_L2DistMapping(quadrEner.template
                      getQuadratures<d>()[0],
                      &mapping);

    fitt_id.compute();
    return fitt_id.result();
}



template<class T> gsMatrix<T>
rescale_domain(gsMatrix<T>& domain, const std::vector<T>& start,
               const std::vector<T>& end)
{

    unsigned s = domain.rows();
    gsMatrix<T> res(s, 2);
    T _start, _end;
    bool use_start_end = ( start.size() == s && end.size() == s );
    for(unsigned i = 0;i < s;i++)
    {
        _start = 0.;
        _end = 1.;
        if(use_start_end)
        {
            _start = start[i];
            _end = end[i];
        }
        res(0, 0) = domain(0, 0)
            + (domain(0, 1) - domain(0, 0)) * _start;
        res(0, 1) = domain(0, 1)
            + (domain(0, 1) - domain(0, 0)) * _end;
    }
    return res;
}

template<class T> gsGeometry<T>*
basisProjectionInterpolation(boxSide side, gsBasis<T>& basis,
                             gsGeometry<T>& geom,
                             gsGeometry<T>& temp,
                             std::vector<T>& start,
                             std::vector<T>& end)
{
    gsBasis<T>* new_basis = basis.boundaryBasis(side).release();
    /// In case the support of basis and geom are different
    gsMatrix<T> supp_template = temp.basis().support();
    gsMatrix<T> supp_c =
        rescale_domain(supp_template, start, end);
    gsMatrix<T> supp_b = new_basis->support();

    int basisDomainDim = supp_b.rows();
    int geomTargetDim = geom.geoDim();
    int tempDomainDim = temp.domainDim();

    int dirOrth = side.direction();

    gsMatrix<T> anch = new_basis->anchors();
    int nAnch = anch.rows();
    gsMatrix<T> image(geomTargetDim, nAnch);
    gsMatrix<T> _image_temp(basisDomainDim, nAnch);
    gsMatrix<T> image_temp(basisDomainDim-1, nAnch);
    gsMatrix<T> param(new_basis->dim(), nAnch);

    std::vector<T> diff(tempDomainDim);
    std::vector<T> coeff(tempDomainDim);
    for(int i = 0;i < tempDomainDim;i++)
    {
        diff[i] = supp_c(i,0) - supp_b(i,0);
        coeff[i] = ( supp_c(i,1) - supp_c(i,0) )
            / ( supp_b(i,1) - supp_b(i,0) );
    }

    for(int i = 0;i < nAnch;i++)
    {
        for(int j = 0;j < tempDomainDim;j++)
            param(j,i) = diff[j] + coeff[j] * anch(j,i);
    }

    temp.eval_into(param, _image_temp);

    int ind;
    for(int i = 0;i < nAnch;i++)
    {
        ind = 0;
        for(int j = 0;j < basisDomainDim;j++)
        {
            if(j != dirOrth)
            {
                image_temp(ind,i) = _image_temp(j, i);
                ind++;
            }
        }
    }

    geom.eval_into(image_temp, image);
    return new_basis->interpolateData(image, anch).release();
}


template<class T> gsGeometry<T>*
basisProjectionInterpolation(boxSide side, gsBasis<T>& basis,
                             gsMatrix<T>& pts, gsMatrix<T>& param,
                             const std::vector<T>& start,
                             const std::vector<T>& end)
{
    gsFittingParam<T> param_fitting;

    gsBasis<T>* new_basis = basis.boundaryBasis(side);
    /// In case the support of basis and geom are different
    gsMatrix<T> bbox;
    getBoundingBoxPts<T>(param, bbox);
    gsMatrix<T> supp_c = rescale_domain(bbox, start, end);
    gsMatrix<T> supp_b = basis->support();

    short_t domainDim = supp_c.rows();
    std::vector<T> diff(domainDim);
    std::vector<T> coeff(domainDim);
    for(unsigned i = 0;i < domainDim;i++)
    {
        diff[i] = supp_b(i,0) - supp_c(i,0);
        coeff[i] = ( supp_b(i,1) - supp_b(i,0) )
            / ( supp_c(i,1) - supp_c(i,0) );
    }

    short_t targetDim = pts.rows();
    int s = pts.cols();
    std::vector<gsMatrix<T> > _new_pts, _new_param;

    for(unsigned i = 0;i < s;i++)
    {
        if(isIncluded<T>(param.col(i), supp_c))
        {
            _new_param.add( gsMatrix<T>(param.col(i)) );
            _new_pts.add( gsMatrix<T>(pts.col(i)) );
        }
    }
    int nPts = _new_param.size();

    gsMatrix<T> new_pts(targetDim, nPts);
    gsMatrix<T> new_param(targetDim, nPts);

    for(unsigned i = 0;i < nPts;i++)
    {
        for(unsigned j = 0;j < domainDim;j++)
            new_param(j,i) = diff[j] + coeff[j] * _new_param[i](j,0);
        new_pts.col(i) = _new_pts[i];
    }

    gsFunctionSet<T>* res = NULL;
    if(domainDim == 1)
        res = fitPoints<1, gsBasis<T>, 2, T>
            (new_pts, new_param, new_basis, param_fitting);
    else
    {
        GISMO_ENSURE(domainDim == 2, "We only consider dimension 2 and 3");
        res = fitPoints<2, gsBasis<T>, 2, T>
            (new_pts, new_param, new_basis, param_fitting);
    }
    return static_cast<gsGeometry<T>*>(res);
}


} /// namespace gismo
